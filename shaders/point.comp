#version 450
//#extension GL_ARB_compute_shader : enable
//#extension GL_ARB_shader_storage_buffer_object : enable

struct Particle {
	vec3 position;
    vec3 color;
    vec3 velocity;
};

struct camera{
    mat4 view;
    mat4 proj;
};

struct modelMatrix {
    mat4 model;
};

layout(binding = 0) uniform UniformBufferObject {
    modelMatrix model;
    camera cam;
    float dt;
} ubo;

layout(std140  binding = 1) readonly buffer SSBO_in {
   Particle inSSBO[ ];
};
layout(std140, binding = 2) buffer SSBO_out {
   Particle outSSBO[ ];
};

// Workgroup Invocation Layout
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main() 
{
    uint index = gl_GlobalInvocationID.x;  

    Particle particle = inSSBO[index];

    outSSBO[index].position = particle.position + particle.velocity * ubo.dt;
    outSSBO[index].velocity = particle.velocity;

    // Flip movement at window border
    if ((outSSBO[index].position.x <= -1.0) || (outSSBO[index].position.x >= 1.0)) {
        outSSBO[index].velocity.x = -outSSBO[index].velocity.x;
    }
    if ((outSSBO[index].position.y <= -1.0) || (outSSBO[index].position.y >= 1.0)) {
        outSSBO[index].velocity.y = -outSSBO[index].velocity.y;
    }

}
/*
// Organization and Indexing
uvec3 nWG = gl_NumWorkGroups;
uvec3 sWG = gl_WorkGroupSize;
uint i = gl_WorkGroupID.x + (nWG.x * gl_WorkGroupID.y) + (nWG.x * nWG.y * gl_WorkGroupID.z);
uint j = gl_LocalInvocationID.x + (sWG.x * gl_LocalInvocationID.y) + (sWG.x * sWG.y *gl_LocalInvocationID.z);
    
// Globals
const float c = 2.0f;
const float e = 2.7182818284;

float radius = 0.001f;


// Calculates acceleration towards a position
vec3 Gravity(vec3 p1, vec3 p2, float m1, float m2){
    vec3 rN = normalize(p2 - p1);
    float dist2 = distance(p2, p1);
    dist2 *= dist2;
    return rN * ((c*c*m1 * m1 * m2) / (4 + c*c*m1*m1*dist2));
}


void main() 
{// Kinematic Motion of the Elements of the System
    vec3 Acceleration;
    if (i != j)
    {// Particle Interaction Calculations
        // Interacting Particle Properties
        float m0 = objMtc[i][0][0];
        float m1 = objMtc[j][0][0];
        vec3 p0 = objMtc[i][3].xyz;
        vec3 p1 = objMtc[j][3].xyz;
        
        // Velocity Calculation
        objVel[i] += Gravity(p0, p1, m0, m1) * dt;

        if (length(objVel[i]) > c)
        {// Sets the Velocity Maximum to the Speed of Light
            normalize(objVel[i]);
            objVel[i] *= c;
        }
        if (distance(p0, p1) <= (objMtc[i][0][0] + objMtc[j][0][0]))
        {
            vec3 rN0 = - normalize(p1 - p0);
            vec3 rN =  - normalize(p0 - p1);
            vec3 v = (objVel[i].xyz + objVel[j].xyz)/2;
            vec3 deflect = rN - 2 * dot(rN, objVel[i].xyz) * objVel[i].xyz;
            objVel[i] = v;
            objVel[j] = v;
        }

        // Update Position
        objMtc[i][3].xyz += objVel[i] * dt;
    }   
}
*/